# Time-series-Analysis and Forecasting with python
# Introduction
Time series analysis comprises methods for analyzing time series data in order to extract meaningful statistics and other characteristics of the data. Time series forecasting is the use of a model to predict future values based on previously observed values.
Time series are widely used for non-stationary data, like economic, weather, stock price, and retail sales in this post. We will demonstrate different approaches for forecasting retail sales time series. Let’s get started!


# The Data
We are using Superstore sales data for time series analysis and forecasting. There are several categories in the Superstore sales data, we start from time series analysis and forecasting for furniture sales. We have a good 4-year furniture sales data.

Timestamp(‘2014–01–06 00:00:00’),  Timestamp(‘2017–12–30 00:00:00’) 

# Data Preprocessing
This step includes removing columns we do not need, check missing values, aggregate sales by date and so on.

# Indexing with Time Series Data
Our current datetime data can be tricky to work with, therefore, we will use the averages daily sales value for that month instead, and we are using the start of each month as the timestamp.

# Visualizing Furniture Sales Time Series Data

![graph1](https://user-images.githubusercontent.com/63221463/159135953-dca2eca6-ea1d-47ec-9121-0f18085cdee8.png)

Some distinguishable patterns appear when we plot the data. The time-series has seasonality pattern, such as sales are always low at the beginning of the year and high at the end of the year. There is always an upward trend within any single year with a couple of low months in the mid of the year.
We can also visualize our data using a method called time-series decomposition that allows us to decompose our time series into three distinct components: trend, seasonality, and noise.

Graph

The plot above clearly shows that the sales of furniture is unstable, along with its obvious seasonality.

# Time series forecasting with ARIMA
We are going to apply one of the most commonly used method for time-series forecasting, known as ARIMA, which stands for Autoregressive Integrated Moving Average.
ARIMA models are denoted with the notation ARIMA(p, d, q). These three parameters account for seasonality, trend, and noise in data.

This step is parameter Selection for our furniture’s sales ARIMA Time Series Model. Our goal here is to use a “grid search” to find the optimal set of parameters that yields the best performance for our model.
The output suggests that SARIMAX(1, 1, 1)x(1, 1, 0, 12) yields the lowest AIC value of 297.78. Therefore we should consider this to be optimal option.
# Fitting the ARIMA model

Graph

It is not perfect, however, our model diagnostics suggests that the model residuals are near normally distributed.

# Validating forecasts
To help us understand the accuracy of our forecasts, we compare predicted sales to real sales of the time series, and we set forecasts to start at 2017–01–01 to the end of the data.

Graph

The line plot is showing the observed values compared to the rolling forecast predictions. Overall, our forecasts align with the true values very well, showing an upward trend starts from the beginning of the year and captured the seasonality toward the end of the year.

The Mean Squared Error of our forecasts is 22993.58

The Root Mean Squared Error of our forecasts is 151.64

In statistics, the mean squared error (MSE) of an estimator measures the average of the squares of the errors — that is, the average squared difference between the estimated values and what is estimated. The MSE is a measure of the quality of an estimator — it is always non-negative, and the smaller the MSE, the closer we are to finding the line of best fit.
Root Mean Square Error (RMSE) tells us that our model was able to forecast the average daily furniture sales in the test set within 151.64 of the real sales. Our furniture daily sales range from around 400 to over 1200. In my opinion, this is a pretty good model so far.

Graph

Our model clearly captured furniture sales seasonality. As we forecast further out into the future, it is natural for us to become less confident in our values. This is reflected by the confidence intervals generated by our model, which grow larger as we move further out into the future.
The above time series analysis for furniture makes me curious about other categories, and how do they compare with each other over time. Therefore, we are going to compare time series of furniture and office supplier.
# Time Series of Furniture vs. Office Supplies
According to our data, there were way more number of sales from Office Supplies than from Furniture over the years.

((2121, 21), (6026, 21))
# Data Exploration
We are going to compare two categories’ sales in the same time period. This means combine two data frames into one and plot these two categories’ time series into one plot.

Graph

We observe that sales of furniture and office supplies shared a similar seasonal pattern. Early of the year is the off season for both of the two categories. It seems summer time is quiet for office supplies too. in addition, average daily sales for furniture are higher than those of office supplies in most of the months. It is understandable, as the value of furniture should be much higher than those of office supplies. Occasionally, office supplies passed furniture on average daily sales. Let’s find out when was the first time office supplies’ sales surpassed those of furniture’s.

Office supplies first time produced higher sales than furniture is 2014–07–01.
It was July 2014!
# Time Series Modeling with Prophet
Released by Facebook in 2017, forecasting tool Prophet is designed for analyzing time-series that display patterns on different time scales such as yearly, weekly and daily. It also has advanced capabilities for modeling the effects of holidays on a time-series and implementing custom changepoints. Therefore, we are using Prophet to get a model up and running.

Graph

Graph

# Compare Forecasts
We already have the forecasts for three years for these two categories into the future. We will now join them together to compare their future forecasts.
# Trend and Forecast Visualization

Graph

Graph
# Trends and Patterns
Now, we can use the Prophet Models to inspect different trends of these two categories in the data.

Graph

Graph

Good to see that the sales for both furniture and office supplies have been linearly increasing over time and will be keep growing, although office supplies’ growth seems slightly stronger.
The worst month for furniture is April, the worst month for office supplies is February. The best month for furniture is December, and the best month for office supplies is October.
There are many time-series analysis we can explore from now on, such as forecast with uncertainty bounds, change point and anomaly detection, forecast time-series with external data source. We have only just started.

# Database Normalization
The following database normalization process are widely used for normalization,

-First Normal Form (1NF)
-Second Normal Form (2NF)
-Third Normal Form (3NF)
-Boyce-Codd Normal Form or Fourth Normal Form (BCNF of 4NF)
-Fifth Normal Form (5NF)
-Sixth Normal Form (6NF)

In this article, we will only focus on the the concepts of 1NF, 2NF and 3NF, and 
First Normal Form (1NF)
Data is stored in tables with rows that can be uniquely identified by a Primary Key.
Data within each table is stored in individual columns in its most reduced form
There are no repeating groups.


# Objective:
In this project we will focus on the first three normalizing process in database, and other forms are out of the scope of this projects.
# Methodology
## First Normal Form
- Data is stored in tables with rows that can be uniquely identified by a Primary Key
- Each column within tables would be reduced form
- There are no repetition of the grouping 
## Second Normal Form
- all the rules from first normal form must be satisfied
- Keeping those columns in a table that are directly related to the primary key 
## Third Normal Form
- all the rules from second normal form must be satisfied
- Between columns dependency within table must be avoided
# Overview of the examples Database
Let us consider the following data base diagrams, there is existing data base with four tables- Projects, Employees, ProjectsEmployees, and JobOrders. Besides, a new table (Customers) for customer information is added with existing database. But, if you observe in diagram, you can see customers tables has not been designed in proper way to support the normal form. Our main objective to update the customers tables so that it can follow the rules of normalization

<img src="image/Fig 1.png" width="600"/>

# Normalizing Examples Database and Discussion
## First Normal Form
### Identification of Problems
Following first normal rules are violated by customers table

- There is no primary key (id)
- Data is not in redundant form. For example, the column ContactPersonAndRole can be divided into two individuals column for example: ContactPerson and ContactPersonRole
- There are two repeating groups of columns in the table. For example, (Project1_ID, Project1_FeedBack) and (Project2_ID, Project2_Feedback). We need to get these removed from this table.
### Steps For First Normalization
- The first thing that I need to do is to add a primary key (id) to this table
- Secondly, I need to split the column ContactPersonAndRole into two individual columns. This can be done in two steps as follows:
  - Rename the original column from ContactPersonAndRole to ContactPerson.
  - Add a new column for ContactPersonRole.
  
 - Finally, in order to satisfy the third rule of the First Normal Form, I need to move the columns Project1_ID, Project1_Feedback, Project2_ID, and Project2_Feedback into a new table. This can be done by creating a new table ProjectFeedbacks and link it back with the Customers and the Projects table. Here, new table ProjectFeedbacks use Foreign Key references to the Customers and Projects table.
The following database diagram will appear after applying all the rules of the first normal form.
<img src="image/Fig 2.png" width="600"/>

# Second Normal Form
## Identification of Problems
From the earlier figure, we can see that he ContactPerson, ContactPersonRole and the PhoneNumber do not directly relate to the ID of the Customers table. That is because the primary key refers to a customer and not to any person or role or the phone number of the contact person.

## Steps For Second Normalization
- So in order to satisfy the second rule, we need removed these columns from table and store these columns in new table named as ContactPerson. Keep in mind, this table contain data related to the contact person not information about customers
- Once, the columns are removed from the Customers table, we need to create a new table that'll store the data for the contact persons. Let us create a new table ContactPersons and relate it to the Customers table with a foreign key relation
Now you can see in the diagram below that a new table has been added and it satisfies the second normal form of the database
<img src="image/Fig 3.png" width="600"/>

# Third Normal Form
## Identification of Problems
In third normal form, along with second normal form, we have to ensure that each columns must be non-transitively independent, that means, each columns should be rely on the primary key column not any other columns. Here, although city and zip code are related to the primary key, they depend on each other and violates non-transitively independent conditions.

## Steps For Third Normalization
In order to fix the problem, we need to remove the city from customer table and create a new table zipcodes to store columns city and zip. This new table can be related to the Customers table via a foreign key relation.

Now that all the changes are performed, lets look at the following figure after the third normal form has also been satisfied
<img src="image/Fig 4.png" width="600"/>


# Contributor Info
- Md Faruk Hossain
  - fhossainisrt@gmail.com
  - fhossain2@isrt.ac.bd
